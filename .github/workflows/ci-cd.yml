name: Build → Push → Deploy to GKE

on:
  push:
    branches: [ main ]

env:
  PROJECT_ID: vivid-science-473308-m7
  REGION: us-central1
  REPOSITORY: my-repo
  IMAGE_NAME: iris-api
  GKE_CLUSTER: autopilot-cluster-1
  GKE_LOCATION: us-central1   # use --region for Autopilot regional clusters
  DEPLOYMENT_NAME: iris-deployment
  CONTAINER_NAME: iris-api
  K8S_MANIFEST_DIR: k8s

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud and kubectl
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ env.PROJECT_ID }}
          install_components: kubectl

      - name: Configure docker for Artifact Registry
        run: |
          echo "Configuring docker credential helper for ${REGION}-docker.pkg.dev"
          gcloud auth configure-docker ${REGION}-docker.pkg.dev --quiet

      - name: Build and push Docker image
        env:
          PROJECT_ID: ${{ env.PROJECT_ID }}
          REGION: ${{ env.REGION }}
          REPOSITORY: ${{ env.REPOSITORY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPOSITORY}/${IMAGE_NAME}:${SHORT_SHA}"
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV
          echo "Building ${IMAGE_URI}"
          docker build -t "${IMAGE_URI}" .
          docker push "${IMAGE_URI}"
          # verify
          docker inspect "${IMAGE_URI}" || true

      - name: Get GKE credentials
        env:
          PROJECT_ID: ${{ env.PROJECT_ID }}
          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}
          GKE_LOCATION: ${{ env.GKE_LOCATION }}
        run: |
          # For Autopilot / regional clusters use --region; for zonal clusters use --zone
          gcloud container clusters get-credentials "${GKE_CLUSTER}" --region "${GKE_LOCATION}" --project "${PROJECT_ID}"

      - name: (Optional) Patch deployment resources for Autopilot / quick scheduling
        run: |
          # If you want to ensure Autopilot will schedule, the deployment's container should request small resources.
          # This command patches the Kubernetes deployment *before* updating image (idempotent).
          kubectl -n default patch deployment "${DEPLOYMENT_NAME}" --type='json' -p='[{
            "op":"replace","path":"/spec/template/spec/containers/0/resources",
            "value":{"requests":{"cpu":"50m","memory":"64Mi"},"limits":{"cpu":"250m","memory":"256Mi"}}
          }]' || true

      - name: Apply k8s manifests (create svc/deploy if not present)
        run: |
          # apply manifests - they should define deployment/service using placeholders or be generic
          kubectl apply -f ${K8S_MANIFEST_DIR}/deployment.yaml
          kubectl apply -f ${K8S_MANIFEST_DIR}/service.yaml

      - name: Update deployment image and wait for rollout
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
        run: |
          # use the IMAGE_URI set earlier in the job
          echo "Setting image for deployment ${DEPLOYMENT_NAME} to ${IMAGE_URI}"
          kubectl -n default set image deployment/${{ env.DEPLOYMENT_NAME }} ${CONTAINER_NAME}=${IMAGE_URI} --record
          kubectl -n default rollout status deployment/${{ env.DEPLOYMENT_NAME }} --timeout=240s

      - name: Verify pods and service
        run: |
          kubectl -n default get pods -l app=iris -o wide
          kubectl -n default get svc iris-service -o wide || true
